import * as React from 'react';

import * as types from '../types';
import * as api from '../core/gws-api';
import * as ui from '../ui';
import * as tools from '../tools';
import * as featureComp from './feature';
import * as listComp from './list';

let {Row, Cell} = ui.Layout;


const EDITOR_HEIGHT = 90;

export interface FormEvent {
    type: string;
    field: types.IModelField;
    value?: any;
    selectedFeature?: types.IFeature;
}

interface FormProps {
    controller: types.IController;
    model: types.IModel;
    feature: types.IFeature;
    values: types.Dict;
    errors?: types.Dict;
    whenChanged: (field: types.IModelField, value: any) => void,
    whenEntered: (field: types.IModelField) => void,
    whenEvent: (field: types.IModelField, type: string, options?: object) => void,
}

interface WidgetProps extends FormProps {
    field: types.IModelField;
    options: types.Dict;
}

interface WidgetState {
    selectedFeatureUid?: string;
    popupVisible?: boolean;
}


class Widget extends React.Component<WidgetProps, WidgetState> {
    state: WidgetState;

    constructor(props) {
        super(props);
        this.state = {}
    }

    changed(value) {
        if (this.props.whenChanged)
            this.props.whenChanged(this.props.field, value);
    }

    entered() {
        if (this.props.whenEntered)
            this.props.whenEntered(this.props.field);
    }

    event(type, opts=null) {
        if (this.props.whenEvent)
            this.props.whenEvent(this.props.field, type, opts);


    }


}

class ReadonlyWidget extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        let s;

        if (tools.empty(value))
            s = ''
        else if (typeof (value) === 'object')
            s = value['title'] || value['id'] || '<...>';
        else
            s = String(value);

        return <ui.TextInput
            value={s}
            disabled
        />
    }
}


class StringWidget extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        return <ui.TextInput
            value={tools.empty(value) ? '' : String(value)}
            whenChanged={v => this.changed(v)}
            whenEntered={v => this.entered()}
        />
    }
}

class IntegerWidget extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        let cc = this.props.controller;
        return <ui.NumberInput
            locale={cc.app.locale}
            value={value}
            whenChanged={v => this.changed(v)}
            whenEntered={v => this.entered()}
        />
    }
}

class FloatWidget extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        let cc = this.props.controller;
        return <ui.NumberInput
            locale={cc.app.locale}
            value={value}
            whenChanged={v => this.changed(v)}
            whenEntered={v => this.entered()}
        />
    }
}

class DateWidget extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        let cc = this.props.controller;
        return <ui.DateInput
            locale={cc.app.locale}
            value={value}
            whenChanged={v => this.changed(v)}
        />
    }
}

class TextboxWidget extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        return <ui.TextArea
            value={tools.empty(value) ? '' : String(value)}
            whenChanged={v => this.changed(v)}
        />
    }
}

class SelectWidget extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        return <ui.Select
            value={tools.empty(value) ? '' : String(value)}
            items={this.props.options['items']}
            whenChanged={v => this.changed(v)}
        />
    }
}

class ComboWidget extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        return <ui.Select
            value={tools.empty(value) ? '' : String(value)}
            items={this.props.options['items']}
            whenChanged={v => this.changed(v)}
            withCombo
        />
    }
}

class MeasurementWidget extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];

        let qty = 0, unit = '';

        let m = String(value).match(/(\d+)\s*(\w+)/);
        if (m) {
            qty = Number(m[1]);
            unit = m[2];
        }

        return <Row>
            <Cell>
                <ui.NumberInput
                    value={qty}
                    whenChanged={v => this.changed(String(v) + unit)}
                    whenEntered={v => this.entered()}
                />
            </Cell>
            <Cell spaced>
                <ui.Select
                    value={unit}
                    items={this.props.options['items']}
                    whenChanged={v => this.changed(String(qty) + v)}
                />
            </Cell>
        </Row>
    }
}



interface FileWidgetValue {
    type: string;
    initValues: Array<string>;
    files?: FileList;
}

class FileWidget extends Widget {
    render() {
        let cc = this.props.controller;
        let field = this.props.field;
        let value = this.props.values[field.name];
        let val: FileWidgetValue;

        if (!value) {
            val = {type: 'FileWidgetValue', initValues: []}
        } else if (typeof value === 'string') {
            val = {type: 'FileWidgetValue', initValues: [value]}
        } else if (Array.isArray(value)) {
            val = {type: 'FileWidgetValue', initValues: value}
        } else {
            val = value as FileWidgetValue;
        }

        return <div className="cmpFormList">
            <listComp.List
                controller={cc}
                items={val.initValues}
                leftButton={it => <ui.Button
                    className='cmpFormFileViewButton'
                />
                }
                content={item => <ui.Link
                    content={item}
                    whenTouched={() => this.event('file.view')}
                />}
            />
            <Row className="cmpFormAuxToolbar">
                <Cell>
                    <ui.FileInput
                        // accept={editor.accept}
                        // multiple={editor.multiple}
                        value={val.files}
                        whenChanged={v => this.changed({
                                type: 'FileWidgetValue',
                                initValues: val.initValues,
                                files: v
                            }
                        )}
                        tooltip={'Datei hochladen'}
                    />
                </Cell>
            </Row>
        </div>
    }
}

class GeometryWidget extends Widget {
    render() {
        let cc = this.props.controller;
        let field = this.props.field;
        let hasGeom = Boolean(this.props.feature.geometry);
        let isDrawing = cc.app.activeTool.tag.includes('Draw');

        return <Row>
            {!hasGeom && <Cell>
                <ui.Button
                    {...tools.cls('cmpFormDrawGeometryButton', isDrawing && 'isActive')}
                    tooltip={'Geometrie erstellen'}
                    whenTouched={v => this.event('geometry.draw')}
                />
            </Cell>}
            {hasGeom && <Cell>
                <ui.Button
                    className='cmpFormEditGeometryButton'
                    tooltip={'Geometrie bearbeiten'}
                    whenTouched={v => this.event('geometry.edit')}
                />
            </Cell>}
        </Row>
    }
}

class RelationListWidget extends Widget {
    render() {
        let cc = this.props.controller;
        let field = this.props.field;

        let activeFeatures = this.props.values[field.name] || [];

        let selectedFeature = null;
        for (let fe of activeFeatures) {
            if (fe.uid === this.state.selectedFeatureUid) {
                selectedFeature = fe;
                break;
            }
        }

        let buttons = <React.Fragment>
            <Cell>
                <ui.Button
                    className='cmpFormListNewButton'
                    tooltip={"neues Objekt"}
                    whenTouched={v => this.event('relation.new', {selectedFeature})}
                />
            </Cell>
            <Cell>
                <ui.Button
                    className='cmpFormListLinkButton'
                    tooltip={"Objekt verbinden"}
                    whenTouched={v => this.event('relation.link', {selectedFeature})}
                />
            </Cell>
            <Cell>
                <ui.Button
                    className='cmpFormListEditButton'
                    tooltip={"Objekt bearbeiten"}
                    disabled={!selectedFeature}
                    whenTouched={v => this.event('relation.edit', {selectedFeature})}
                />
            </Cell>
            <Cell>
                <ui.Button
                    className='cmpFormListUnlinkButton'
                    tooltip={"Objekt trennen"}
                    disabled={!selectedFeature}
                    whenTouched={v => this.event('relation.unlink', {selectedFeature})}
                />
            </Cell>
            <Cell>
                <ui.Button
                    className='cmpFormListDeleteButton'
                    tooltip={"Objekt lÃ¶schen"}
                    disabled={!selectedFeature}
                    whenTouched={v => this.event('relation.delete', {selectedFeature})}
                />
            </Cell>

        </React.Fragment>

        return <div className="cmpFormList">
            <featureComp.List
                controller={cc}
                features={activeFeatures}
                content={f => <ui.Link
                    content={f.elements.title}
                    whenTouched={() => this.setState({selectedFeatureUid: f.uid})}
                />}
                isSelected={f => f.uid === this.state.selectedFeatureUid}
            />
            <Row className="cmpFormAuxToolbar">
                {!this.state.popupVisible && buttons}
            </Row>
        </div>
    }


}

class RelationSelectWidget extends Widget {
    render() {
        let cc = this.props.controller;
        let field = this.props.field;

        let feature = this.props.values[field.name];
        let items = [];
        let fmap = {};

        for (let f of this.props.field.relations[0].model.getLayer().features) {
            fmap[f.uid] = f;
            items.push({text: f.elements.title, value: String(f.uid)})
        }

        return <ui.Select
            value={feature ? String(feature.uid) : null}
            items={items}
            whenChanged={v => this.changed(fmap[v])}
        />;

    }
}


//

const _WIDGETS = {
    'combo': ComboWidget,
    'date': DateWidget,
    'file': FileWidget,
    'float': FloatWidget,
    'geometry': GeometryWidget,
    'integer': IntegerWidget,
    'readonly': ReadonlyWidget,
    'relationList': RelationListWidget,
    'relationSelect': RelationSelectWidget,
    'select': SelectWidget,
    'string': StringWidget,
    'textbox': TextboxWidget,
    'measurement': MeasurementWidget,
}


//


export class Form extends React.PureComponent<FormProps> {

    renderField(field: types.IModelField) {
        if (!field.widget)
            return;

        let cc = this.props.controller;

        let err = this.props.errors ? this.props.errors[field.name] : null;
        let props = {
            field,
            options: field.widget['options'] || {},
            ...this.props
        };
        let widget = React.createElement(_WIDGETS[field.widget.type], props);

        return <React.Fragment key={field.name}>
            <tr className={err ? 'isError' : ''}>
                <th>
                    {field.title}
                </th>
                <td>
                    {widget}
                </td>
            </tr>
            <tr {...tools.cls('cmpFormError', err && 'isActive')}>
                <th>&nbsp;</th>
                <td>{err && cc.__(err)}</td>
            </tr>
        </React.Fragment>

    }

    render() {
        return <table className="cmpForm">
            <tbody>
            {this.props.model.fields.map(f => this.renderField(f))}
            </tbody>
        </table>
    }
}
