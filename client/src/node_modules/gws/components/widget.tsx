import * as React from 'react';

import * as types from '../types';
import * as api from '../core/gws-api';
import * as ui from '../ui';
import * as tools from '../tools';
import * as featureComp from './feature';
import * as listComp from './list';
import * as documentComp from './document';
import * as gws from "gws";

let {Row, Cell} = ui.Layout;


interface Props {
    controller: types.IController;
    feature: types.IFeature;
    field: types.IModelField;
    options: types.Dict;
    values: types.Dict;
    readOnly?: boolean;
    whenChanged: (field: types.IModelField, value: any) => void,
    whenEntered: (field: types.IModelField) => void,
}

interface State {
    selectedFeatureUid?: string;
}


export class Widget<P extends Props = Props, S extends State = State> extends React.Component<P, S> {
    state: S;

    constructor(props) {
        super(props);
        this.state = {} as S;
    }

    changed(value) {
        if (this.props.whenChanged)
            this.props.whenChanged(this.props.field, value);
    }

    entered() {
        if (this.props.whenEntered)
            this.props.whenEntered(this.props.field);
    }
}

export class StaticText extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        let s;

        if (tools.empty(value))
            s = ''
        else if (typeof (value) === 'object')
            s = value['title'] || value['id'] || '<...>';
        else
            s = String(value);

        return <ui.Text
            content={s}
        />
    }
}


export class Input extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        return <ui.TextInput
            value={tools.empty(value) ? '' : String(value)}
            whenChanged={v => this.changed(v)}
            whenEntered={v => this.entered()}
            readOnly={this.props.readOnly}
        />
    }
}

export class Integer extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        let cc = this.props.controller;
        return <ui.NumberInput
            locale={cc.app.locale}
            value={value}
            whenChanged={v => this.changed(v)}
            whenEntered={v => this.entered()}
            readOnly={this.props.readOnly}
        />
    }
}

export class Float extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        let cc = this.props.controller;
        return <ui.NumberInput
            locale={cc.app.locale}
            value={value}
            whenChanged={v => this.changed(v)}
            whenEntered={v => this.entered()}
            readOnly={this.props.readOnly}
        />
    }
}

export class Date extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        let cc = this.props.controller;
        return <ui.DateInput
            locale={cc.app.locale}
            value={value}
            whenChanged={v => this.changed(v)}
            withClear
            readOnly={this.props.readOnly}
        />
    }
}

export class Textarea extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        return <ui.TextArea
            value={tools.empty(value) ? '' : String(value)}
            whenChanged={v => this.changed(v)}
            readOnly={this.props.readOnly}
        />
    }
}

export class Checkbox extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        return <ui.Toggle
            type="checkbox"
            value={String(value) === '1'}
            whenChanged={v => this.changed(v ? '1' : '0')}
            readOnly={this.props.readOnly}
        />
    }
}

export class Select extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        return <ui.Select
            value={tools.empty(value) ? '' : String(value)}
            items={this.props.options['items']}
            whenChanged={v => this.changed(v)}
            readOnly={this.props.readOnly}
        />
    }
}

export class Combo extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];
        return <ui.Select
            value={tools.empty(value) ? '' : String(value)}
            items={this.props.options['items']}
            whenChanged={v => this.changed(v)}
            withCombo
            readOnly={this.props.readOnly}
        />
    }
}

export class Measurement extends Widget {
    render() {
        let field = this.props.field;
        let value = this.props.values[field.name];

        let qty = 0, unit = '';

        let m = String(value).match(/(\d+)\s*(\w+)/);
        if (m) {
            qty = Number(m[1]);
            unit = m[2];
        }

        return <Row>
            <Cell>
                <ui.NumberInput
                    value={qty}
                    whenChanged={v => this.changed(String(v) + unit)}
                    whenEntered={v => this.entered()}
                    readOnly={this.props.readOnly}
                />
            </Cell>
            <Cell spaced>
                <ui.Select
                    value={unit}
                    items={this.props.options['items']}
                    whenChanged={v => this.changed(String(qty) + v)}
                    readOnly={this.props.readOnly}
                />
            </Cell>
        </Row>
    }
}


interface FileProps extends Props {
    whenViewButtonTouched?: (w: Widget) => void
}

export class File extends Widget<FileProps> {
    download(fe: types.IFeature) {
        let url = this.props.options['downloadUrl'] || '';
        if (url) {
            url = url.replace('{uid}', fe.uid) + '/projectUid/' + this.props.controller.app.project.uid;
            window.open(url, 'gwsDownload')
        }
    }

    render() {
        let cc = this.props.controller;
        let field = this.props.field;
        let value = this.props.values[field.name];
        let oldValue = this.props.feature.getAttribute(field.name);

        let previewUrl = this.props.options['previewUrl'] || '';

        let items = [];
        if (oldValue)
            items.push(oldValue.name);

        return <div className="cmpFileWidget">
            {oldValue && <documentComp.Document
                controller={cc}
                document={
                    {
                        uid: this.props.feature.uid,
                        label: oldValue.name,
                        mime: oldValue.mime,
                        previewUrl: previewUrl.replace('{uid}', this.props.feature.uid),
                    }
                }
                whenTouched={() => this.download(this.props.feature)}
            />}
            <Row className="cmpFormAuxToolbar">
                <Cell>
                    <ui.FileInput
                        // accept={editor.accept}
                        // multiple={editor.multiple}
                        value={value}
                        whenChanged={v => this.changed(v)}
                        tooltip={'Datei hochladen'}
                    />
                </Cell>
            </Row>
        </div>
    }
}


interface GeometryProps extends Props {
    whenNewButtonTouched?: (w: Widget) => void;
    whenEditButtonTouched?: (w: Widget) => void;
}


export class Geometry extends Widget<GeometryProps> {
    render() {
        let cc = this.props.controller;
        let field = this.props.field;
        let hasGeom = Boolean(this.props.feature.geometry);
        let isDrawing = cc.app.activeTool.tag.includes('Draw');

        return <Row>
            {!hasGeom && this.props.whenNewButtonTouched && <Cell>
                <ui.Button
                    {...tools.cls('cmpFormDrawGeometryButton', isDrawing && 'isActive')}
                    tooltip={'Geometrie erstellen'}
                    whenTouched={v => this.props.whenNewButtonTouched(this)}
                />
            </Cell>}
            {hasGeom && this.props.whenEditButtonTouched && <Cell>
                <ui.Button
                    className='cmpFormEditGeometryButton'
                    tooltip={'Geometrie bearbeiten'}
                    whenTouched={v => this.props.whenEditButtonTouched(this)}
                />
            </Cell>}
        </Row>
    }
}

interface FeatureListProps extends Props {
    whenNewButtonTouched?: (w: Widget) => void;
    whenLinkButtonTouched?: (w: Widget) => void;
    whenEditButtonTouched?: (w: Widget, feature?: types.IFeature) => void;
    whenUnlinkButtonTouched?: (w: Widget, feature?: types.IFeature) => void;
    whenDeleteButtonTouched?: (w: Widget, feature?: types.IFeature) => void;
}

class GenericFeatureList extends Widget<FeatureListProps> {
    selectedFeature() {
        let field = this.props.field;
        let activeFeatures = this.props.values[field.name] || [];

        for (let fe of activeFeatures) {
            if (fe.uid === this.state.selectedFeatureUid) {
                return fe;
            }
        }
    }

    buttons() {
        let sel = this.selectedFeature();

        return <React.Fragment>
            {this.props.whenNewButtonTouched && <Cell>
                <ui.Button
                    className='cmpFormListNewButton'
                    tooltip={"neues Objekt"}
                    whenTouched={v => this.props.whenNewButtonTouched(this)}
                />
            </Cell>}
            {this.props.whenLinkButtonTouched && <Cell>
                <ui.Button
                    className='cmpFormListLinkButton'
                    tooltip={"Objekt verbinden"}
                    whenTouched={v => this.props.whenLinkButtonTouched(this)}
                />
            </Cell>}
            {this.props.whenEditButtonTouched && <Cell>
                <ui.Button
                    className='cmpFormListEditButton'
                    tooltip={"Objekt bearbeiten"}
                    disabled={!sel}
                    whenTouched={v => this.props.whenEditButtonTouched(this, sel)}
                />
            </Cell>}
            {this.props.whenUnlinkButtonTouched && <Cell>
                <ui.Button
                    className='cmpFormListUnlinkButton'
                    tooltip={"Objekt trennen"}
                    disabled={!sel}
                    whenTouched={v => this.props.whenUnlinkButtonTouched(this, sel)}
                />
            </Cell>}
            {this.props.whenDeleteButtonTouched && <Cell>
                <ui.Button
                    className='cmpFormListDeleteButton'
                    tooltip={"Objekt löschen"}
                    disabled={!sel}
                    whenTouched={v => this.props.whenDeleteButtonTouched(this, sel)}
                />
            </Cell>}
        </React.Fragment>
    }
}

export class FeatureList extends GenericFeatureList {
    render() {
        let cc = this.props.controller;
        let field = this.props.field;
        let activeFeatures = this.props.values[field.name] || [];

        let zoomTo = f => this.props.controller.update({
            marker: {
                features: [f],
                mode: 'zoom draw fade'
            }
        });

        let select = f => this.setState({selectedFeatureUid: f.uid});

        let leftButton = f => {
            if (f.geometryName)
                return <gws.components.list.Button
                    className="cmpListZoomListButton"
                    whenTouched={() => zoomTo(f)}
                />
            else
                return <gws.components.list.Button
                    className="cmpListDefaultListButton"
                    whenTouched={() => select(f)}
                />
        }

        return <div className="cmpFormList">
            <featureComp.List
                controller={cc}
                features={activeFeatures}
                content={f => <ui.Link
                    content={f.elements.title}
                    whenTouched={() => select(f)}
                />}
                isSelected={f => f.uid === this.state.selectedFeatureUid}
                leftButton={leftButton}
            />
            <Row className="cmpFormAuxToolbar">
                {this.buttons()}
            </Row>
        </div>
    }
}


export class DocumentList extends GenericFeatureList {
    download(fe: types.IFeature) {
        let url = this.props.options['downloadUrl'] || '';
        if (url) {
            url = url.replace('{uid}', fe.uid) + '/projectUid/' + this.props.controller.app.project.uid;
            window.open(url, 'gwsDownload')
        }
    }

    render() {
        let cc = this.props.controller;
        let field = this.props.field;
        let activeFeatures: Array<types.IFeature> = this.props.values[field.name] || [];

        let documents: Array<documentComp.DocumentItem> = [];
        let previewUrl = this.props.options['previewUrl'] || '';
        let downloadUrl = this.props.options['downloadUrl'] || '';

        for (let fe of activeFeatures) {
            let file = fe.getAttribute(this.props.options['fileFieldName']);
            documents.push({
                uid: fe.uid,
                label: fe.elements.title,
                mime: file ? file.mime : '',
                previewUrl: previewUrl.replace('{uid}', fe.uid),
                downloadUrl: downloadUrl.replace('{uid}', fe.uid),
            })
        }

        let sel = this.selectedFeature();

        return <div className="cmpFormList">
            <documentComp.DocumentList
                controller={cc}
                documents={documents}
                whenTouched={f => this.setState({selectedFeatureUid: f.uid})}
                isSelected={f => f.uid === this.state.selectedFeatureUid}
            />
            <Row className="cmpFormAuxToolbar">
                {this.buttons()}
                <Cell flex/>
                <Cell>
                    <ui.Button
                        className='cmpFormFileDownloadButton'
                        tooltip={"Herunterladen"}
                        disabled={!sel}
                        whenTouched={v => this.download(sel)}
                    />
                </Cell>
            </Row>
        </div>
    }


}

interface FeatureSelectProps extends Props {
    features: Array<types.IFeature>;
    withSearch?: boolean;
}


export class FeatureSelect extends Widget<FeatureSelectProps> {
    render() {
        let cc = this.props.controller;
        let field = this.props.field;

        let feature = this.props.values[field.name];
        let items = [];
        let fmap = {};

        for (let f of (this.props.features || [])) {
            fmap[f.uid] = f;
            items.push({text: f.elements.title, value: String(f.uid)})
        }

        return <ui.Select
            value={feature ? String(feature.uid) : null}
            items={items}
            withSearch={this.props.withSearch}
            whenChanged={v => this.changed(fmap[v])}
            searchMode={{anySubstring: true, caseSensitive: false}}
        />;
    }
}

interface FeatureSuggestProps extends Props {
    features: Array<types.IFeature>;
    searchText?: string;
    whenSearchTextChanged?: (w: Widget, value: string) => void;
}

export class FeatureSuggest extends Widget<FeatureSuggestProps> {
    render() {
        let cc = this.props.controller;
        let field = this.props.field;

        let feature = this.props.values[field.name];
        let items = [];
        let fmap = {};

        for (let f of (this.props.features || [])) {
            fmap[f.uid] = f;
            items.push({text: f.elements.title, value: String(f.uid)})
        }

        return <ui.Suggest
            value={feature ? String(feature.uid) : null}
            items={items}
            text={this.props.searchText}
            whenChanged={v => this.changed(fmap[v])}
            whenTextChanged={v => this.props.whenSearchTextChanged(this, v)}
        />;
    }
}

export const WIDGETS = {
    'combo': Combo,
    'dateInput': Date,
    'file': File,
    'floatInput': Float,
    'geometry': Geometry,
    'integerInput': Integer,
    'staticText': StaticText,
    'featureList': FeatureList,
    'documentList': DocumentList,
    'featureSelect': FeatureSelect,
    'featureSuggest': FeatureSuggest,
    'select': Select,
    'input': Input,
    'textarea': Textarea,
    'measurement': Measurement,
    'checkBox': Checkbox,
}


