class DatabaseModel(Model):
    """Database-based data model."""

    db: 'DatabaseProvider'
    """Database provider."""
    sqlFilter: str
    """Literal SQL condition applied when selecting rows."""
    tableName: str
    """Table name associated with this model."""

    def table(self) -> 'sqlalchemy.Table':
        """Return the SQLAlchemy Table object for this database model."""

    def column(self, column_name: str) -> 'sqlalchemy.Column':
        """Retrieve the SQLAlchemy Column object for the given column name."""

    def uid_column(self) -> 'sqlalchemy.Column':
        """Return the SQLAlchemy Column object representing the unique identifier column."""

    def fetch_features(self, select: 'sqlalchemy.Select') -> list['Feature']:
        """Fetch features from the database based on the provided SQLAlchemy Select statement."""

    def build_select(self, mc: 'ModelContext') -> Optional['sqlalchemy.Select']:
        """Build a SQLAlchemy Select statement based on the provided ModelContext."""


class ColumnDescription(Data):
    """Description of a dataset column."""

    columnIndex: int
    """The index of the column within the table."""
    comment: str
    """Column comment or description provided in the database metadata."""
    default: str
    """The default value assigned to the column, if any."""
    geometrySrid: int
    """The Spatial Reference Identifier (SRID) for geometry columns."""
    geometryType: GeometryType
    """The type of geometry stored in the column (e.g., Point, Polygon)."""
    isAutoincrement: bool
    """Indicates if the column is auto-incremented."""
    isNullable: bool
    """Specifies if the column permits NULL values."""
    isPrimaryKey: bool
    """Specifies if the column is part of the primary key."""
    isUnique: bool
    """Indicates if the column has a unique constraint."""
    hasDefault: bool
    """Indicates if the column has a database-defined default value."""
    isIndexed: bool
    """Indicates if the column has an index."""
    name: str
    """The name of the column."""
    nativeType: str
    """The database-specific data type of the column."""
    options: dict
    """Additional options or configurations for the column, if any."""
    type: AttributeType
    """The abstract type of the column used in higher-level processing."""


class DataSetDescription(Data):
    """Description of a dataset, like a DB table or a GDAL data set."""

    columns: list[ColumnDescription]
    """A list of column descriptions."""
    columnMap: dict[str, ColumnDescription]
    """A dictionary mapping column names to their descriptions."""
    fullName: str
    """The full name of the dataset, including schema if applicable."""
    geometryName: str
    """The name of the geometry column, if any."""
    geometrySrid: int
    """The Spatial Reference Identifier (SRID) for the geometry."""
    geometryType: GeometryType
    """The type of geometry stored in the dataset."""
    name: str
    """The name of the dataset or table."""
    schema: str
    """The schema to which the dataset belongs."""


class DatabaseManager(Node):
    """Database manager."""

    providers: list['DatabaseProvider']
    """A list of database providers managed by this DatabaseManager."""

    def create_provider(self, cfg: Config, **kwargs) -> 'DatabaseProvider':
        """Create and return a DatabaseProvider instance based on the given configuration.

        Args:
            cfg: The configuration object for the database provider.
            **kwargs: Additional keyword arguments to customize the provider creation.

        Returns:
            DatabaseProvider: A new database provider instance.
        """

    def find_provider(self, uid: Optional[str] = None, ext_type: Optional[str] = None) -> Optional['DatabaseProvider']:
        """Find and return a DatabaseProvider that matches the given UID and/or extension type.

        Args:
            uid: The unique identifier of the database provider to find.
            ext_type: The type of the database provider to find.

        Returns:
            The matching database provider if found, otherwise None.
        """


DatabaseTableAlike: TypeAlias = Union['sqlalchemy.Table', str]
"""An SQLAlchemy ``Table`` object or a string table name."""


DatabaseStmt: TypeAlias = Union['sqlalchemy.Executable', str]
"""An Executable SQLAlchemy object or a string SQL statement."""


class DatabaseConnection:
    """Database connection.

    Extends ``sqlalchemy.Connection`` and provides some convenience methods.
    """

    saConn: 'sqlalchemy.Connection'

    def __enter__(self) -> 'DatabaseConnection': ...

    def __exit__(self, exc_type, exc_value, traceback): ...

    def execute(self, stmt: 'sqlalchemy.Executable', params=None) -> 'sqlalchemy.CursorResult': ...

    def commit(self): ...

    def rollback(self): ...

    def close(self): ...

    def exec(self, stmt: 'DatabaseStmt', **params) -> 'sqlalchemy.CursorResult': ...
    
    def exec_commit(self, stmt: 'DatabaseStmt', **params) -> 'sqlalchemy.CursorResult': ...
    
    def exec_rollback(self, stmt: 'DatabaseStmt', **params) -> 'sqlalchemy.CursorResult': ...

    def fetch_all(self, stmt: 'DatabaseStmt', **params) -> list[dict]: ...

    def fetch_first(self, stmt: 'DatabaseStmt', **params) -> dict | None: ...

    def fetch_scalars(self, stmt: 'DatabaseStmt', **params) -> list: ...

    def fetch_strings(self, stmt: 'DatabaseStmt', **params) -> list[str]: ...

    def fetch_ints(self, stmt: 'DatabaseStmt', **params) -> list[int]: ...

    def fetch_scalar(self, stmt: 'DatabaseStmt', **params) -> Any: ...

    def fetch_string(self, stmt: 'DatabaseStmt', **params) -> str | None: ...

    def fetch_int(self, stmt: 'DatabaseStmt', **params) -> str | None: ...


class DatabaseProvider(Node):
    """Database Provider.

    A database Provider wraps SQLAlchemy ``Engine`` and ``Connection`` objects
    and provides common db functionality.
    """

    def connect(self) -> 'DatabaseConnection':
        """Context manager for SQLAlchemy ``Connection``.

        Context calls to this method can be nested. An inner call is a no-op, as no new connection is created.
        Only the outermost connection is closed upon exit::

            with db.connect():
                ...
                with db.connect():  # no-op
                    ...
                # connection remains open
                ...
            # connection closed
        """

    def engine_options(self, **kwargs):
        """Add defaults to the SA engine options."""

    def url(self) -> str:
        """Return the connection URL."""

    def engine(self) -> 'sqlalchemy.Engine':
        """Get SQLAlchemy ``Engine`` object for this provider."""

    def create_engine(self, **kwargs) -> 'sqlalchemy.Engine':
        """CreateSQLAlchemy ``Engine`` object for this provider."""

    def describe(self, table: DatabaseTableAlike) -> 'DataSetDescription':
        """Describe a table."""

    def table(self, table: 'DatabaseTableAlike', **kwargs) -> 'sqlalchemy.Table':
        """SQLAlchemy ``Table`` object for a specific table."""

    def column(self, table: DatabaseTableAlike, column_name: str) -> 'sqlalchemy.Column':
        """SQLAlchemy ``Column`` object for a specific column."""

    def count(self, table: DatabaseTableAlike) -> int:
        """Return table record count or 0 if the table does not exist."""

    def has_table(self, table_name: str) -> bool:
        """Check if a specific table exists."""

    def has_column(self, table: DatabaseTableAlike, column_name: str) -> bool:
        """Check if a specific column exists."""

    def join_table_name(self, schema: str, name: str) -> str:
        """Create a full table name from the schema and table names."""

    def split_table_name(self, table_name: str) -> tuple[str, str]:
        """Split a full table name into the schema and table names."""

    def table_bounds(self, table: DatabaseTableAlike) -> Optional[Bounds]:
        """Compute a bounding box for the table primary geometry."""

    def select_text(self, sql: str, **kwargs) -> list[dict]:
        """Execute a textual SELECT stmt and return a list of record dicts."""

    def execute_text(self, sql: str, **kwargs) -> 'sqlalchemy.CursorResult':
        """Execute a textual DML stmt and return a result."""
