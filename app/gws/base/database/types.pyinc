class DatabaseModel(Model):
    """Database-based data model."""

    db: 'DatabaseProvider'
    """Database provider."""
    sqlFilter: str
    """Literal SQL condition applied when selecting rows."""
    tableName: str
    """Table name associated with this model."""

    def table(self) -> 'sqlalchemy.Table':
        """Return the SQLAlchemy Table object for this database model."""

    def column(self, column_name: str) -> 'sqlalchemy.Column':
        """Retrieve the SQLAlchemy Column object for the given column name."""

    def uid_column(self) -> 'sqlalchemy.Column':
        """Return the SQLAlchemy Column object representing the unique identifier column."""


class ColumnDescription(Data):
    """Description of a dataset column."""

    columnIndex: int
    """The index of the column within the table."""
    comment: str
    """Column comment or description provided in the database metadata."""
    default: str
    """The default value assigned to the column, if any."""
    geometrySrid: int
    """The Spatial Reference Identifier (SRID) for geometry columns."""
    geometryType: GeometryType
    """The type of geometry stored in the column (e.g., Point, Polygon)."""
    isAutoincrement: bool
    """Indicates if the column is auto-incremented."""
    isNullable: bool
    """Specifies if the column permits NULL values."""
    isPrimaryKey: bool
    """Specifies if the column is part of the primary key."""
    isUnique: bool
    """Indicates if the column has a unique constraint."""
    hasDefault: bool
    """Indicates if the column has a database-defined default value."""
    isIndexed: bool
    """Indicates if the column has an index."""
    name: str
    """The name of the column."""
    nativeType: str
    """The database-specific data type of the column."""
    options: dict
    """Additional options or configurations for the column, if any."""
    type: AttributeType
    """The abstract type of the column used in higher-level processing."""


class DataSetDescription(Data):
    """Description of a dataset, like a DB table or a GDAL data set."""

    columns: list[ColumnDescription]
    """A list of column descriptions."""
    columnMap: dict[str, ColumnDescription]
    """A dictionary mapping column names to their descriptions."""
    fullName: str
    """The full name of the dataset, including schema if applicable."""
    geometryName: str
    """The name of the geometry column, if any."""
    geometrySrid: int
    """The Spatial Reference Identifier (SRID) for the geometry."""
    geometryType: GeometryType
    """The type of geometry stored in the dataset."""
    name: str
    """The name of the dataset or table."""
    schema: str
    """The schema to which the dataset belongs."""


class DatabaseManager(Node):
    """Database manager."""

    providers: list['DatabaseProvider']
    """A list of database providers managed by this DatabaseManager."""

    def create_provider(self, cfg: Config, **kwargs) -> 'DatabaseProvider':
        """Create and return a DatabaseProvider instance based on the given configuration.

        Args:
            cfg: The configuration object for the database provider.
            **kwargs: Additional keyword arguments to customize the provider creation.

        Returns:
            DatabaseProvider: A new database provider instance.
        """

    def find_provider(self, uid: Optional[str] = None, ext_type: Optional[str] = None) -> Optional['DatabaseProvider']:
        """Find and return a DatabaseProvider that matches the given UID and/or extension type.

        Args:
            uid: The unique identifier of the database provider to find.
            ext_type: The type of the database provider to find.

        Returns:
            The matching database provider if found, otherwise None.
        """


DatabaseTableAlike: TypeAlias = Union['sqlalchemy.Table', str]
"""An SQLAlchemy ``Table`` object or a string table name."""


DatabaseStmt: TypeAlias = Union['sqlalchemy.Executable', str]
"""An Executable SQLAlchemy object or a string SQL statement."""


class DatabaseConnection:
    """Database connection.

    Extends ``sqlalchemy.Connection`` and provides some convenience methods.
    """

    def exec(self, statement: 'DatabaseStmt', **params) -> 'sqlalchemy.CursorResult':
        ...

    def exec_commit(self, statement: 'DatabaseStmt', **params) -> 'sqlalchemy.CursorResult':
        ...

    def get_all(self, statement: 'DatabaseStmt', **params) -> list[dict]:
        ...

    def get_first(self, statement: 'DatabaseStmt', **params) -> dict | None:
        ...

    def get_scalars(self, statement: 'DatabaseStmt', **params) -> list:
        ...

    def get_scalar(self, statement: 'DatabaseStmt', **params) -> Any:
        ...


class DatabaseProvider(Node):
    """Database Provider.

    A database Provider wraps SQLAlchemy ``Engine`` and ``Connection`` objects
    and provides common db functionality.
    """

    def column(self, table: DatabaseTableAlike, column_name: str) -> 'sqlalchemy.Column':
        """SQLAlchemy ``Column`` object for a specific column."""

    def connect(self) -> Generator['DatabaseConnection', None, None]:
        """Context manager for a SA ``Connection``.

        Context calls to this method can be nested. An inner call is a no-op, as no new connection is created.
        Only the outermost connection is closed upon exit::

            with db.connect():
                ...
                with db.connect(): # no-op
                    ...
                # connection remains open
                ...
            # connection closed
        """

    def describe(self, table: DatabaseTableAlike) -> 'DataSetDescription':
        """Describe a table."""

    def count(self, table: DatabaseTableAlike) -> int:
        """Return table record count or 0 if the table does not exist."""

    def engine_options(self, **kwargs):
        """Add defaults to the SA engine options."""

    def url(self):
        """Return the connection URL."""

    def engine(self, **kwargs) -> 'sqlalchemy.Engine':
        """SA ``Engine`` object for this provider."""

    def has_column(self, table: DatabaseTableAlike, column_name: str) -> bool:
        """Check if a specific column exists."""

    def has_table(self, table_name: str) -> bool:
        """Check if a specific table exists."""

    def join_table_name(self, schema: str, name: str) -> str:
        """Create a full table name from the schema and table names."""

    def split_table_name(self, table_name: str) -> tuple[str, str]:
        """Split a full table name into the schema and table names."""

    def table(self, table_name: str, **kwargs) -> 'sqlalchemy.Table':
        """SA ``Table`` object for a specific table."""

    def table_bounds(self, table: DatabaseTableAlike) -> Optional[Bounds]:
        """Compute a bounding box for the table primary geometry."""

    def select_text(self, sql: str, **kwargs) -> list[dict]:
        """Execute a textual SELECT statement and return a list of record dicts."""

    def execute_text(self, sql: str, **kwargs) -> 'sqlalchemy.CursorResult':
        """Execute a textual DML statement and return a result."""
